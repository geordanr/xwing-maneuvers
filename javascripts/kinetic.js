// Generated by CoffeeScript 1.6.3
(function() {
  var exportObj;

  exportObj = typeof exports !== "undefined" && exports !== null ? exports : this;

  exportObj.SMALL_BASE_WIDTH = 40;

  exportObj.LARGE_BASE_WIDTH = 80;

  exportObj.TEMPLATE_WIDTH = exportObj.SMALL_BASE_WIDTH / 2;

  exportObj.BANK_INSIDE_RADII = ['', 75, 122, 173];

  exportObj.TURN_INSIDE_RADII = ['', 27, 52, 79];

  exportObj.Ship = (function() {
    function Ship(args) {
      var _ref;
      this.name = (_ref = args.name) != null ? _ref : 'Unnamed Ship';
      this.size = args.size;
      this.move_history = [];
    }

    return Ship;

  })();

  exportObj.ShipInstance = (function() {
    function ShipInstance(args) {
      var nub_offset;
      this.ship = args.ship;
      this.width = (function() {
        switch (this.ship.size) {
          case 'small':
            return exportObj.SMALL_BASE_WIDTH;
          case 'large':
            return exportObj.LARGE_BASE_WIDTH;
          default:
            throw new Error("Invalid size " + this.size);
        }
      }).call(this);
      this.group = new Kinetic.Group({
        x: args.x,
        y: args.y,
        offsetX: this.width / 2,
        offsetY: this.width / 2,
        rotation: args.heading_deg
      });
      this.group.add(new Kinetic.Rect({
        x: 0,
        y: 0,
        width: this.width,
        height: this.width,
        stroke: 'black',
        strokeWidth: 1
      }));
      this.group.add(new Kinetic.Line({
        points: [1, 0, this.width / 2, this.width / 2, this.width - 1, 0],
        stroke: 'black',
        strokeWidth: 1
      }));
      nub_offset = exportObj.TEMPLATE_WIDTH / 2;
      this.group.add(new Kinetic.Rect({
        x: (this.width / 2) - nub_offset - 1,
        y: -2,
        width: 1,
        height: 2,
        stroke: 'black',
        strokeWidth: 1
      }));
      this.group.add(new Kinetic.Rect({
        x: (this.width / 2) + nub_offset - 1,
        y: -2,
        width: 1,
        height: 2,
        stroke: 'black',
        strokeWidth: 1
      }));
      this.group.add(new Kinetic.Rect({
        x: (this.width / 2) - nub_offset - 1,
        y: this.width,
        width: 1,
        height: 2,
        stroke: 'black',
        strokeWidth: 1
      }));
      this.group.add(new Kinetic.Rect({
        x: (this.width / 2) + nub_offset - 1,
        y: this.width,
        width: 1,
        height: 2,
        stroke: 'black',
        strokeWidth: 1
      }));
    }

    ShipInstance.prototype.placeTemplate = function(template) {
      template.shape.move(this.group.getTransform().point({
        x: this.width / 2,
        y: 0
      }));
      return template.shape.rotation(this.group.getRotation());
    };

    return ShipInstance;

  })();

  exportObj.Template = (function() {
    function Template(args) {
      var dir, dist;
      this.type = args.type;
      this.distance = args.distance;
      this.direction = args.direction;
      this.shape = (function() {
        switch (this.type) {
          case 'straight':
          case 'koiogran':
            return new Kinetic.Rect({
              x: 0,
              y: 0,
              offsetX: exportObj.TEMPLATE_WIDTH / 2,
              offsetY: 0,
              width: exportObj.TEMPLATE_WIDTH,
              height: -exportObj.SMALL_BASE_WIDTH * this.distance,
              stroke: 'black',
              strokeWidth: 1
            });
          case 'bank':
            dir = this.direction;
            dist = this.distance;
            return (function(dir, dist) {
              return new Kinetic.Shape({
                drawFunc: function(ctx) {
                  var angle, radius;
                  radius = exportObj.BANK_INSIDE_RADII[dist];
                  ctx.beginPath();
                  switch (dir) {
                    case 'left':
                      angle = -Math.PI / 4.0;
                      ctx.arc(-radius - (exportObj.TEMPLATE_WIDTH / 2), 0, radius, angle, 0);
                      ctx.lineTo(exportObj.TEMPLATE_WIDTH / 2, 0);
                      ctx.arc(-radius - (exportObj.TEMPLATE_WIDTH / 2), 0, radius + exportObj.TEMPLATE_WIDTH, 0, angle, true);
                      break;
                    case 'right':
                      angle = -3 * Math.PI / 4.0;
                      ctx.arc(radius + (exportObj.TEMPLATE_WIDTH / 2), 0, radius, angle, Math.PI, true);
                      ctx.lineTo(-exportObj.TEMPLATE_WIDTH / 2, 0);
                      ctx.arc(radius + (exportObj.TEMPLATE_WIDTH / 2), 0, radius + exportObj.TEMPLATE_WIDTH, Math.PI, angle);
                      break;
                    default:
                      throw new Error("Invalid direction " + dir);
                  }
                  ctx.closePath();
                  return ctx.strokeShape(this);
                },
                stroke: 'black',
                strokeWidth: 1
              });
            })(dir, dist);
          case 'turn':
            dir = this.direction;
            dist = this.distance;
            return (function(dir, dist) {
              return new Kinetic.Shape({
                drawFunc: function(ctx) {
                  var angle, radius;
                  angle = -Math.PI / 2;
                  radius = exportObj.TURN_INSIDE_RADII[dist];
                  ctx.beginPath();
                  switch (dir) {
                    case 'left':
                      ctx.arc(-radius - (exportObj.TEMPLATE_WIDTH / 2), 0, radius, angle, 0);
                      ctx.lineTo(exportObj.TEMPLATE_WIDTH / 2, 0);
                      ctx.arc(-radius - (exportObj.TEMPLATE_WIDTH / 2), 0, radius + exportObj.TEMPLATE_WIDTH, 0, angle, true);
                      break;
                    case 'right':
                      ctx.arc(radius + (exportObj.TEMPLATE_WIDTH / 2), 0, radius + exportObj.TEMPLATE_WIDTH, angle, Math.PI, true);
                      ctx.lineTo(exportObj.TEMPLATE_WIDTH / 2, 0);
                      ctx.arc(radius + (exportObj.TEMPLATE_WIDTH / 2), 0, radius, Math.PI, angle);
                      break;
                    default:
                      throw new Error("Invalid direction " + dir);
                  }
                  ctx.closePath();
                  return ctx.strokeShape(this);
                },
                stroke: 'black',
                strokeWidth: 1
              });
            })(dir, dist);
        }
      }).call(this);
    }

    Template.prototype.move = function(shipinst) {
      var d, end_center, new_center, rotation, start_center, x_offset;
      rotation = 0;
      start_center = {
        x: shipinst.group.getOffsetX(),
        y: shipinst.group.getOffsetY()
      };
      end_center = (function() {
        switch (this.type) {
          case 'straight':
            return new Kinetic.Transform().translate(0, -this.distance * exportObj.SMALL_BASE_WIDTH - shipinst.width).point(start_center);
          case 'bank':
            switch (this.direction) {
              case 'left':
                d = exportObj.BANK_INSIDE_RADII[this.distance] - ((shipinst.width - exportObj.TEMPLATE_WIDTH) / 2);
                rotation = -45;
                end_center = new Kinetic.Transform().translate(d, -shipinst.width).point(start_center);
                end_center = new Kinetic.Transform().rotate(-Math.PI / 4).point(end_center);
                return end_center = new Kinetic.Transform().translate(-d, 0).point(end_center);
              case 'right':
                d = exportObj.BANK_INSIDE_RADII[this.distance] + ((shipinst.width + exportObj.TEMPLATE_WIDTH) / 2);
                rotation = 45;
                end_center = new Kinetic.Transform().translate(-d, -shipinst.width).point(start_center);
                end_center = new Kinetic.Transform().rotate(Math.PI / 4).point(end_center);
                return end_center = new Kinetic.Transform().translate(d, 0).point(end_center);
              default:
                throw new Error("Invalid direction " + this.direction);
            }
            break;
          case 'turn':
            switch (this.direction) {
              case 'left':
                d = exportObj.TURN_INSIDE_RADII[this.distance] - ((shipinst.width - exportObj.TEMPLATE_WIDTH) / 2);
                rotation = -90;
                end_center = new Kinetic.Transform().translate(d, -shipinst.width).point(start_center);
                end_center = new Kinetic.Transform().rotate(-Math.PI / 2).point(end_center);
                return end_center = new Kinetic.Transform().translate(-d, 0).point(end_center);
              case 'right':
                d = exportObj.TURN_INSIDE_RADII[this.distance] + ((shipinst.width + exportObj.TEMPLATE_WIDTH) / 2);
                rotation = 90;
                end_center = new Kinetic.Transform().translate(-d, -shipinst.width).point(start_center);
                end_center = new Kinetic.Transform().rotate(Math.PI / 2).point(end_center);
                return end_center = new Kinetic.Transform().translate(d, 0).point(end_center);
              default:
                throw new Error("Invalid direction " + this.direction);
            }
            break;
          case 'koiogran':
            rotation = 180;
            end_center = new Kinetic.Transform().translate(-shipinst.group.getOffsetX(), -shipinst.group.getOffsetY()).point(start_center);
            end_center = new Kinetic.Transform().rotate(Math.PI).point(end_center);
            return end_center = new Kinetic.Transform().translate(shipinst.group.getOffsetX(), -shipinst.group.getOffsetY() - (this.distance * exportObj.SMALL_BASE_WIDTH)).point(end_center);
          case 'barrelroll':
            x_offset = ship.width + (this.distance * exportObj.SMALL_BASE_WIDTH);
            switch (this.direction) {
              case 'left':
                return t.translate(-x_offset, -this.end_distance_from_front + this.start_distance_from_front);
              case 'right':
                return t.translate(x_offset, -this.end_distance_from_front + this.start_distance_from_front);
              case 'leftforward':
                t.translate(-ship.width / 2, this.start_distance_from_front - (ship.width / 2) - exportObj.BANK_INSIDE_RADII[this.distance]);
                t.rotate(Math.PI / 4);
                return t.translate(-ship.width / 2, -this.end_distance_from_front + (ship.width / 2) + exportObj.BANK_INSIDE_RADII[this.distance]);
              case 'leftback':
                t.translate(-ship.width / 2, this.start_distance_from_front - (ship.width / 2) + exportObj.TEMPLATE_WIDTH + exportObj.BANK_INSIDE_RADII[this.distance]);
                t.rotate(-Math.PI / 4);
                return t.translate(-ship.width / 2, -exportObj.BANK_INSIDE_RADII[this.distance] - exportObj.TEMPLATE_WIDTH + (ship.width / 2) - this.end_distance_from_front);
              case 'rightforward':
                t.translate(ship.width / 2, this.start_distance_from_front - (ship.width / 2) - exportObj.BANK_INSIDE_RADII[this.distance]);
                t.rotate(-Math.PI / 4);
                return t.translate(ship.width / 2, -this.end_distance_from_front + (ship.width / 2) + exportObj.BANK_INSIDE_RADII[this.distance]);
              case 'rightback':
                t.translate(ship.width / 2, this.start_distance_from_front - (ship.width / 2) + exportObj.TEMPLATE_WIDTH + exportObj.BANK_INSIDE_RADII[this.distance]);
                t.rotate(Math.PI / 4);
                return t.translate(ship.width / 2, -exportObj.BANK_INSIDE_RADII[this.distance] - exportObj.TEMPLATE_WIDTH + (ship.width / 2) - this.end_distance_from_front);
              default:
                throw new Error("Invalid direction " + this.direction);
            }
            break;
          default:
            throw new Error("Invalid template type " + this.type);
        }
      }).call(this);
      if (this.type === 'koiogran') {
        rotation = 180;
      }
      new_center = shipinst.group.getTransform().point(end_center);
      return new ShipInstance({
        ship: shipinst.ship,
        x: new_center.x,
        y: new_center.y,
        heading_deg: shipinst.group.getRotation() + rotation
      });
    };

    return Template;

  })();

}).call(this);

/*
//@ sourceMappingURL=kinetic.map
*/
